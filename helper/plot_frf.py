#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""Plot periodicity and FRF for the duffing equation. Data generated by
helper/simulate_data.py
"""

import numpy as np
import scipy.io
import matplotlib.pyplot as plt
import os
import sys
sys.path.insert(1, os.path.join(sys.path[0], '..'))

# Perodicity stuff
# from vib.common import db
# from vib.signal2 import Signal
# from vib.frf import FRF
# from vib.rfs import RFS
from common import db
from signal2 import Signal
from frf import FRF
from rfs import RFS

saveplot = True
saveplot = False

nonlin = '0e00'
#nonlin = '5e08'
forcing = '100'
ftype = 'multisine'
# ftype = 'sweep'
abspath =  os.path.dirname(os.path.realpath(sys.argv[0]))
mat = np.load(abspath + '/../data/' + 'duffing_' + nonlin + ftype + forcing + '.npz')

t = mat['t']
y = mat['y']
dy = mat['dy']
ddy = mat['ddy']
fs = mat['fs']
f1 = mat['f1']
f2 = mat['f2']
nsper = mat['nsper']
nper = mat['nper'].item()
u = mat['u']
print('Number of periods: {:d}'.format(nper))

# Make sure forcing and disp are equal in length. Should be the case now where
# the interpolated force is saved.
if len(u) != len(y):
    diff = len(u) - len(y)
    y = np.append(y,np.zeros(diff))
    print('Appended {:d} zero\'s to y. Len(y): {:d}'.format(diff, len(y)))

# which dof to show:
ido = 0
# don't include first measurement as the first force point is not repeated.
relpath = '/../plots/' + 'duffing_periodicity_' + nonlin + ftype + forcing
filename = abspath + relpath

signal = Signal(u, y, fs)
# signal.periodicity(nsper, ido, offset=1, savefig={'save':saveplot,'fname':filename})

fmin = 5
fmax = 150

# select periods to include in FRF. Chosen visually from periodicity plot.
# Remember that it is zero-based
per=[0]
per=[6,7]
#per = np.arange(15,20)

# choose which periods to use
signal.cut(nsper, per, offset=1)
frf = FRF(signal, fmin, fmax)
freq, H = frf.periodic()

H = H[ido,:]

fig1 = plt.figure()
plt.clf()
plt.plot(freq, np.angle(H)/ np.pi * 180 )
plt.title('FRF for dof {}. Periods included {}'.format(ido,', '.join(map(str,per))))
plt.xlabel('Frequency (Hz)')
plt.ylabel('Phase angle (deg)')
#plt.ylim([-180, 180])
plt.yticks(np.linspace(-180,180,360/90))

# Coherence is only calculated for random forcing
# plt.figure()
# plt.clf()
# plt.plot(freq, G2 )
# plt.title('FRF for dof {}'.format(ido))
# plt.xlabel('Frequency (Hz)')
# plt.ylabel('Coherence')

fig2 = plt.figure()
plt.clf()
plt.plot(freq, db(np.abs(H)))
plt.title('FRF for dof {}. Periods included {}'.format(ido,', '.join(map(str,per))))
plt.xlabel('Frequency (Hz)')
# For linear scale: 'Amplitude (m/N)'
plt.ylabel('Amplitude (dB)')

if saveplot:
    relpath = '/../plots/' + 'duffing_frfphase_' + nonlin + ftype + forcing
    filename = abspath + relpath
    fig1.savefig(filename + '.png')
    fig1.savefig(filename + '.pdf')
    print('plot saved as {}'.format(relpath))
    relpath = '/../plots/' + 'duffing_frfamp_' + nonlin + ftype + forcing
    filename = abspath + relpath
    fig2.savefig(filename + '.png')
    fig2.savefig(filename + '.pdf')
    print('plot saved as {}'.format(relpath))

# plt.show()


import scipy.io
relpath = '/../data/T03a_Data/'
path = abspath + relpath
mat =  scipy.io.loadmat(path + 'f16_x.mat')
# mat =  scipy.io.loadmat(path + 'f16.mat')

fs =400
dofs = [66, 102]
# y = mat['x'][dofs,:]
# dy = mat['xd'][dofs,:]
# ddy = mat['xdd'][dofs,:]
y = mat['x']
dy = mat['xd']
ddy = mat['xdd']

print(y.shape)
y[dofs,:]

signal = Signal(y, y, fs)
signal.set_values(y=y, dy=dy, ddy=ddy)

rfs = RFS(signal, dofs)
rfs.plot()
